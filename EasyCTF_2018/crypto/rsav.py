(N, e1) = (9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 11)
(N, e2) = (9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 41)
(N, e3) = (9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 67623079903)
(N, e4) = (9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 5161910578063)
(N, e5) = (9247606623523847772698953161616455664821867183571218056970099751301682205123115716089486799837447397925308887976775994817175994945760278197527909621793469, 175238643578591220695210061216092361657427152135258210375005373467710731238260448371371798471959129039441888531548193154205671)

import math

e = (e1*e2*e3*e4*e5) 
print(e)
print(N)

# OK, so "encrypting 5 times" is just the same as encrypting with one value.
# How to get this? Perhaps the modulus is weak?

# let's try Fermat factorisation
def sqrt(n):
    (lower, upper) = (0, n)
    while lower < upper - 1:
        mid = (lower + upper) // 2
        if mid*mid <= n:
            lower = mid
        else:
            upper = mid
    return lower

def issq(n):
    s = sqrt(n)
    return s*s == n

s = sqrt(N)
for x in range(s+1, s+2000000):
    if issq(N - x*x): print(x)
